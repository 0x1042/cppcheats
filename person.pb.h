// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: person.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_person_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_person_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#    error This file was generated by a newer version of protoc which is
#    error incompatible with your Protocol Buffer headers. Please update
#    error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#    error This file was generated by an older version of protoc which is
#    error incompatible with your Protocol Buffer headers. Please
#    error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/map.h> // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/port_undef.inc>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_person_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_person_2eproto {
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_person_2eproto;
namespace tutorial {
class Person;
struct PersonDefaultTypeInternal;
extern PersonDefaultTypeInternal _Person_default_instance_;
class Person_ExtrasEntry_DoNotUse;
struct Person_ExtrasEntry_DoNotUseDefaultTypeInternal;
extern Person_ExtrasEntry_DoNotUseDefaultTypeInternal _Person_ExtrasEntry_DoNotUse_default_instance_;
class PhoneNumber;
struct PhoneNumberDefaultTypeInternal;
extern PhoneNumberDefaultTypeInternal _PhoneNumber_default_instance_;
} // namespace tutorial
PROTOBUF_NAMESPACE_OPEN
template <>::tutorial::Person * Arena::CreateMaybeMessage<::tutorial::Person>(Arena *);
template <>::tutorial::Person_ExtrasEntry_DoNotUse * Arena::CreateMaybeMessage<::tutorial::Person_ExtrasEntry_DoNotUse>(Arena *);
template <>::tutorial::PhoneNumber * Arena::CreateMaybeMessage<::tutorial::PhoneNumber>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace tutorial {

enum PhoneType : int {
    MOBILE = 0,
    HOME = 1,
    WORK = 2,
    PhoneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    PhoneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PhoneType_IsValid(int value);
constexpr PhoneType PhoneType_MIN = MOBILE;
constexpr PhoneType PhoneType_MAX = WORK;
constexpr int PhoneType_ARRAYSIZE = PhoneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor * PhoneType_descriptor();
template <typename T> inline const std::string & PhoneType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PhoneType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PhoneType_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(PhoneType_descriptor(), enum_t_value);
}
inline bool PhoneType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PhoneType * value) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhoneType>(PhoneType_descriptor(), name, value);
}
enum Gender : int {
    UNKNOWN = 0,
    MALE = 1,
    FEMALE = 2,
    Gender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Gender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Gender_IsValid(int value);
constexpr Gender Gender_MIN = UNKNOWN;
constexpr Gender Gender_MAX = FEMALE;
constexpr int Gender_ARRAYSIZE = Gender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor * Gender_descriptor();
template <typename T> inline const std::string & Gender_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gender>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Gender_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(Gender_descriptor(), enum_t_value);
}
inline bool Gender_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Gender * value) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Gender>(Gender_descriptor(), name, value);
}
enum Role : int {
    CIVILIAN = 0,
    SOLDIER = 1,
    Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Role_IsValid(int value);
constexpr Role Role_MIN = CIVILIAN;
constexpr Role Role_MAX = SOLDIER;
constexpr int Role_ARRAYSIZE = Role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor * Role_descriptor();
template <typename T> inline const std::string & Role_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Role>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Role_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(Role_descriptor(), enum_t_value);
}
inline bool Role_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Role * value) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Role>(Role_descriptor(), name, value);
}
// ===================================================================

class PhoneNumber final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.PhoneNumber) */ {
public:
    inline PhoneNumber() : PhoneNumber(nullptr) {}
    ~PhoneNumber() override;
    explicit PROTOBUF_CONSTEXPR PhoneNumber(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PhoneNumber(const PhoneNumber & from);
    PhoneNumber(PhoneNumber && from) noexcept : PhoneNumber() { *this = ::std::move(from); }

    inline PhoneNumber & operator=(const PhoneNumber & from) {
        CopyFrom(from);
        return *this;
    }
    inline PhoneNumber & operator=(PhoneNumber && from) noexcept {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor * descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor * GetDescriptor() { return default_instance().GetMetadata().descriptor; }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection * GetReflection() { return default_instance().GetMetadata().reflection; }
    static const PhoneNumber & default_instance() { return *internal_default_instance(); }
    static inline const PhoneNumber * internal_default_instance() {
        return reinterpret_cast<const PhoneNumber *>(&_PhoneNumber_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(PhoneNumber & a, PhoneNumber & b) { a.Swap(&b); }
    inline void Swap(PhoneNumber * other) {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PhoneNumber * other) {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PhoneNumber * New(::PROTOBUF_NAMESPACE_ID::Arena * arena = nullptr) const final { return CreateMaybeMessage<PhoneNumber>(arena); }
    using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
    void CopyFrom(const PhoneNumber & from);
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    void MergeFrom(const PhoneNumber & from) { PhoneNumber::MergeImpl(*this, from); }

private:
    static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message & to_msg, const ::PROTOBUF_NAMESPACE_ID::Message & from_msg);

public:
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char * _InternalParse(const char * ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext * ctx) final;
    uint8_t * _InternalSerialize(uint8_t * target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream * stream) const final;
    int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena * arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(PhoneNumber * other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() { return "tutorial.PhoneNumber"; }

protected:
    explicit PhoneNumber(::PROTOBUF_NAMESPACE_ID::Arena * arena, bool is_message_owned = false);

public:
    static const ClassData _class_data_;
    const ::PROTOBUF_NAMESPACE_ID::Message::ClassData * GetClassData() const final;

    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNumberFieldNumber = 1,
        kPtFieldNumber = 2,
    };
    // string number = 1;
    void clear_number();
    const std::string & number() const;
    template <typename ArgT0 = const std::string &, typename... ArgT> void set_number(ArgT0 && arg0, ArgT... args);
    std::string * mutable_number();
    PROTOBUF_NODISCARD std::string * release_number();
    void set_allocated_number(std::string * number);

private:
    const std::string & _internal_number() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_number(const std::string & value);
    std::string * _internal_mutable_number();

public:
    // .tutorial.PhoneType pt = 2;
    void clear_pt();
    ::tutorial::PhoneType pt() const;
    void set_pt(::tutorial::PhoneType value);

private:
    ::tutorial::PhoneType _internal_pt() const;
    void _internal_set_pt(::tutorial::PhoneType value);

public:
    // @@protoc_insertion_point(class_scope:tutorial.PhoneNumber)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
        int pt_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_person_2eproto;
};
// -------------------------------------------------------------------

class Person_ExtrasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<
                                        Person_ExtrasEntry_DoNotUse,
                                        std::string,
                                        std::string,
                                        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
                                        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<
        Person_ExtrasEntry_DoNotUse,
        std::string,
        std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
        SuperType;
    Person_ExtrasEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR Person_ExtrasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit Person_ExtrasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena * arena);
    void MergeFrom(const Person_ExtrasEntry_DoNotUse & other);
    static const Person_ExtrasEntry_DoNotUse * internal_default_instance() {
        return reinterpret_cast<const Person_ExtrasEntry_DoNotUse *>(&_Person_ExtrasEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(std::string * s) {
        return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s->data(),
            static_cast<int>(s->size()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE,
            "tutorial.Person.ExtrasEntry.key");
    }
    static bool ValidateValue(std::string * s) {
        return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s->data(),
            static_cast<int>(s->size()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE,
            "tutorial.Person.ExtrasEntry.value");
    }
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
    friend struct ::TableStruct_person_2eproto;
};

// -------------------------------------------------------------------

class Person final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Person) */ {
public:
    inline Person() : Person(nullptr) {}
    ~Person() override;
    explicit PROTOBUF_CONSTEXPR Person(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Person(const Person & from);
    Person(Person && from) noexcept : Person() { *this = ::std::move(from); }

    inline Person & operator=(const Person & from) {
        CopyFrom(from);
        return *this;
    }
    inline Person & operator=(Person && from) noexcept {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor * descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor * GetDescriptor() { return default_instance().GetMetadata().descriptor; }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection * GetReflection() { return default_instance().GetMetadata().reflection; }
    static const Person & default_instance() { return *internal_default_instance(); }
    static inline const Person * internal_default_instance() { return reinterpret_cast<const Person *>(&_Person_default_instance_); }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(Person & a, Person & b) { a.Swap(&b); }
    inline void Swap(Person * other) {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Person * other) {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Person * New(::PROTOBUF_NAMESPACE_ID::Arena * arena = nullptr) const final { return CreateMaybeMessage<Person>(arena); }
    using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
    void CopyFrom(const Person & from);
    using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
    void MergeFrom(const Person & from) { Person::MergeImpl(*this, from); }

private:
    static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message & to_msg, const ::PROTOBUF_NAMESPACE_ID::Message & from_msg);

public:
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char * _InternalParse(const char * ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext * ctx) final;
    uint8_t * _InternalSerialize(uint8_t * target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream * stream) const final;
    int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena * arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Person * other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() { return "tutorial.Person"; }

protected:
    explicit Person(::PROTOBUF_NAMESPACE_ID::Arena * arena, bool is_message_owned = false);

private:
    static void ArenaDtor(void * object);

public:
    static const ClassData _class_data_;
    const ::PROTOBUF_NAMESPACE_ID::Message::ClassData * GetClassData() const final;

    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNumbersFieldNumber = 5,
        kExtrasFieldNumber = 100,
        kNameFieldNumber = 2,
        kEmailFieldNumber = 3,
        kIdFieldNumber = 1,
        kAgeFieldNumber = 4,
        kGenderFieldNumber = 6,
        kRoleFieldNumber = 7,
    };
    // repeated .tutorial.PhoneNumber numbers = 5;
    int numbers_size() const;

private:
    int _internal_numbers_size() const;

public:
    void clear_numbers();
    ::tutorial::PhoneNumber * mutable_numbers(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tutorial::PhoneNumber> * mutable_numbers();

private:
    const ::tutorial::PhoneNumber & _internal_numbers(int index) const;
    ::tutorial::PhoneNumber * _internal_add_numbers();

public:
    const ::tutorial::PhoneNumber & numbers(int index) const;
    ::tutorial::PhoneNumber * add_numbers();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tutorial::PhoneNumber> & numbers() const;

    // map<string, string> extras = 100;
    int extras_size() const;

private:
    int _internal_extras_size() const;

public:
    void clear_extras();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> & _internal_extras() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> * _internal_mutable_extras();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> & extras() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> * mutable_extras();

    // string name = 2;
    void clear_name();
    const std::string & name() const;
    template <typename ArgT0 = const std::string &, typename... ArgT> void set_name(ArgT0 && arg0, ArgT... args);
    std::string * mutable_name();
    PROTOBUF_NODISCARD std::string * release_name();
    void set_allocated_name(std::string * name);

private:
    const std::string & _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string & value);
    std::string * _internal_mutable_name();

public:
    // string email = 3;
    void clear_email();
    const std::string & email() const;
    template <typename ArgT0 = const std::string &, typename... ArgT> void set_email(ArgT0 && arg0, ArgT... args);
    std::string * mutable_email();
    PROTOBUF_NODISCARD std::string * release_email();
    void set_allocated_email(std::string * email);

private:
    const std::string & _internal_email() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string & value);
    std::string * _internal_mutable_email();

public:
    // int32 id = 1;
    void clear_id();
    int32_t id() const;
    void set_id(int32_t value);

private:
    int32_t _internal_id() const;
    void _internal_set_id(int32_t value);

public:
    // uint32 age = 4;
    void clear_age();
    uint32_t age() const;
    void set_age(uint32_t value);

private:
    uint32_t _internal_age() const;
    void _internal_set_age(uint32_t value);

public:
    // .tutorial.Gender gender = 6;
    void clear_gender();
    ::tutorial::Gender gender() const;
    void set_gender(::tutorial::Gender value);

private:
    ::tutorial::Gender _internal_gender() const;
    void _internal_set_gender(::tutorial::Gender value);

public:
    // .tutorial.Role role = 7;
    void clear_role();
    ::tutorial::Role role() const;
    void set_role(::tutorial::Role value);

private:
    ::tutorial::Role _internal_role() const;
    void _internal_set_role(::tutorial::Role value);

public:
    // @@protoc_insertion_point(class_scope:tutorial.Person)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tutorial::PhoneNumber> numbers_;
        ::PROTOBUF_NAMESPACE_ID::internal::MapField<
            Person_ExtrasEntry_DoNotUse,
            std::string,
            std::string,
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
            extras_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
        int32_t id_;
        uint32_t age_;
        int gender_;
        int role_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_person_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// PhoneNumber

// string number = 1;
inline void PhoneNumber::clear_number() {
    _impl_.number_.ClearToEmpty();
}
inline const std::string & PhoneNumber::number() const {
    // @@protoc_insertion_point(field_get:tutorial.PhoneNumber.number)
    return _internal_number();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PhoneNumber::set_number(ArgT0 && arg0, ArgT... args) {
    _impl_.number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:tutorial.PhoneNumber.number)
}
inline std::string * PhoneNumber::mutable_number() {
    std::string * _s = _internal_mutable_number();
    // @@protoc_insertion_point(field_mutable:tutorial.PhoneNumber.number)
    return _s;
}
inline const std::string & PhoneNumber::_internal_number() const {
    return _impl_.number_.Get();
}
inline void PhoneNumber::_internal_set_number(const std::string & value) {
    _impl_.number_.Set(value, GetArenaForAllocation());
}
inline std::string * PhoneNumber::_internal_mutable_number() {
    return _impl_.number_.Mutable(GetArenaForAllocation());
}
inline std::string * PhoneNumber::release_number() {
    // @@protoc_insertion_point(field_release:tutorial.PhoneNumber.number)
    return _impl_.number_.Release();
}
inline void PhoneNumber::set_allocated_number(std::string * number) {
    if (number != nullptr) {
    } else {
    }
    _impl_.number_.SetAllocated(number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.number_.IsDefault()) {
        _impl_.number_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:tutorial.PhoneNumber.number)
}

// .tutorial.PhoneType pt = 2;
inline void PhoneNumber::clear_pt() {
    _impl_.pt_ = 0;
}
inline ::tutorial::PhoneType PhoneNumber::_internal_pt() const {
    return static_cast<::tutorial::PhoneType>(_impl_.pt_);
}
inline ::tutorial::PhoneType PhoneNumber::pt() const {
    // @@protoc_insertion_point(field_get:tutorial.PhoneNumber.pt)
    return _internal_pt();
}
inline void PhoneNumber::_internal_set_pt(::tutorial::PhoneType value) {
    _impl_.pt_ = value;
}
inline void PhoneNumber::set_pt(::tutorial::PhoneType value) {
    _internal_set_pt(value);
    // @@protoc_insertion_point(field_set:tutorial.PhoneNumber.pt)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Person

// int32 id = 1;
inline void Person::clear_id() {
    _impl_.id_ = 0;
}
inline int32_t Person::_internal_id() const {
    return _impl_.id_;
}
inline int32_t Person::id() const {
    // @@protoc_insertion_point(field_get:tutorial.Person.id)
    return _internal_id();
}
inline void Person::_internal_set_id(int32_t value) {
    _impl_.id_ = value;
}
inline void Person::set_id(int32_t value) {
    _internal_set_id(value);
    // @@protoc_insertion_point(field_set:tutorial.Person.id)
}

// string name = 2;
inline void Person::clear_name() {
    _impl_.name_.ClearToEmpty();
}
inline const std::string & Person::name() const {
    // @@protoc_insertion_point(field_get:tutorial.Person.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Person::set_name(ArgT0 && arg0, ArgT... args) {
    _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:tutorial.Person.name)
}
inline std::string * Person::mutable_name() {
    std::string * _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:tutorial.Person.name)
    return _s;
}
inline const std::string & Person::_internal_name() const {
    return _impl_.name_.Get();
}
inline void Person::_internal_set_name(const std::string & value) {
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string * Person::_internal_mutable_name() {
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string * Person::release_name() {
    // @@protoc_insertion_point(field_release:tutorial.Person.name)
    return _impl_.name_.Release();
}
inline void Person::set_allocated_name(std::string * name) {
    if (name != nullptr) {
    } else {
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:tutorial.Person.name)
}

// string email = 3;
inline void Person::clear_email() {
    _impl_.email_.ClearToEmpty();
}
inline const std::string & Person::email() const {
    // @@protoc_insertion_point(field_get:tutorial.Person.email)
    return _internal_email();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Person::set_email(ArgT0 && arg0, ArgT... args) {
    _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:tutorial.Person.email)
}
inline std::string * Person::mutable_email() {
    std::string * _s = _internal_mutable_email();
    // @@protoc_insertion_point(field_mutable:tutorial.Person.email)
    return _s;
}
inline const std::string & Person::_internal_email() const {
    return _impl_.email_.Get();
}
inline void Person::_internal_set_email(const std::string & value) {
    _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string * Person::_internal_mutable_email() {
    return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string * Person::release_email() {
    // @@protoc_insertion_point(field_release:tutorial.Person.email)
    return _impl_.email_.Release();
}
inline void Person::set_allocated_email(std::string * email) {
    if (email != nullptr) {
    } else {
    }
    _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:tutorial.Person.email)
}

// uint32 age = 4;
inline void Person::clear_age() {
    _impl_.age_ = 0u;
}
inline uint32_t Person::_internal_age() const {
    return _impl_.age_;
}
inline uint32_t Person::age() const {
    // @@protoc_insertion_point(field_get:tutorial.Person.age)
    return _internal_age();
}
inline void Person::_internal_set_age(uint32_t value) {
    _impl_.age_ = value;
}
inline void Person::set_age(uint32_t value) {
    _internal_set_age(value);
    // @@protoc_insertion_point(field_set:tutorial.Person.age)
}

// repeated .tutorial.PhoneNumber numbers = 5;
inline int Person::_internal_numbers_size() const {
    return _impl_.numbers_.size();
}
inline int Person::numbers_size() const {
    return _internal_numbers_size();
}
inline void Person::clear_numbers() {
    _impl_.numbers_.Clear();
}
inline ::tutorial::PhoneNumber * Person::mutable_numbers(int index) {
    // @@protoc_insertion_point(field_mutable:tutorial.Person.numbers)
    return _impl_.numbers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tutorial::PhoneNumber> * Person::mutable_numbers() {
    // @@protoc_insertion_point(field_mutable_list:tutorial.Person.numbers)
    return &_impl_.numbers_;
}
inline const ::tutorial::PhoneNumber & Person::_internal_numbers(int index) const {
    return _impl_.numbers_.Get(index);
}
inline const ::tutorial::PhoneNumber & Person::numbers(int index) const {
    // @@protoc_insertion_point(field_get:tutorial.Person.numbers)
    return _internal_numbers(index);
}
inline ::tutorial::PhoneNumber * Person::_internal_add_numbers() {
    return _impl_.numbers_.Add();
}
inline ::tutorial::PhoneNumber * Person::add_numbers() {
    ::tutorial::PhoneNumber * _add = _internal_add_numbers();
    // @@protoc_insertion_point(field_add:tutorial.Person.numbers)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tutorial::PhoneNumber> & Person::numbers() const {
    // @@protoc_insertion_point(field_list:tutorial.Person.numbers)
    return _impl_.numbers_;
}

// .tutorial.Gender gender = 6;
inline void Person::clear_gender() {
    _impl_.gender_ = 0;
}
inline ::tutorial::Gender Person::_internal_gender() const {
    return static_cast<::tutorial::Gender>(_impl_.gender_);
}
inline ::tutorial::Gender Person::gender() const {
    // @@protoc_insertion_point(field_get:tutorial.Person.gender)
    return _internal_gender();
}
inline void Person::_internal_set_gender(::tutorial::Gender value) {
    _impl_.gender_ = value;
}
inline void Person::set_gender(::tutorial::Gender value) {
    _internal_set_gender(value);
    // @@protoc_insertion_point(field_set:tutorial.Person.gender)
}

// .tutorial.Role role = 7;
inline void Person::clear_role() {
    _impl_.role_ = 0;
}
inline ::tutorial::Role Person::_internal_role() const {
    return static_cast<::tutorial::Role>(_impl_.role_);
}
inline ::tutorial::Role Person::role() const {
    // @@protoc_insertion_point(field_get:tutorial.Person.role)
    return _internal_role();
}
inline void Person::_internal_set_role(::tutorial::Role value) {
    _impl_.role_ = value;
}
inline void Person::set_role(::tutorial::Role value) {
    _internal_set_role(value);
    // @@protoc_insertion_point(field_set:tutorial.Person.role)
}

// map<string, string> extras = 100;
inline int Person::_internal_extras_size() const {
    return _impl_.extras_.size();
}
inline int Person::extras_size() const {
    return _internal_extras_size();
}
inline void Person::clear_extras() {
    _impl_.extras_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> & Person::_internal_extras() const {
    return _impl_.extras_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> & Person::extras() const {
    // @@protoc_insertion_point(field_map:tutorial.Person.extras)
    return _internal_extras();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> * Person::_internal_mutable_extras() {
    return _impl_.extras_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string> * Person::mutable_extras() {
    // @@protoc_insertion_point(field_mutable_map:tutorial.Person.extras)
    return _internal_mutable_extras();
}

#ifdef __GNUC__
#    pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace tutorial

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::tutorial::PhoneType> : ::std::true_type {};
template <> inline const EnumDescriptor * GetEnumDescriptor<::tutorial::PhoneType>() {
    return ::tutorial::PhoneType_descriptor();
}
template <> struct is_proto_enum<::tutorial::Gender> : ::std::true_type {};
template <> inline const EnumDescriptor * GetEnumDescriptor<::tutorial::Gender>() {
    return ::tutorial::Gender_descriptor();
}
template <> struct is_proto_enum<::tutorial::Role> : ::std::true_type {};
template <> inline const EnumDescriptor * GetEnumDescriptor<::tutorial::Role>() {
    return ::tutorial::Role_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_person_2eproto
